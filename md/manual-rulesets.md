
# Rulesets

Some pre-configured rulesets are provided in `rulesets/*.toml`.
A pre-configured ruleset can be used in the three standard ways (rename to
`.svlint.toml` and place in the project root, the `--config` argument, or via
the `SVLINT_CONFIG` environment variable).
Pre-configured rulesets reside in `rulesets/*.toml`.
There are two methods of specifying those TOML files:

1. Simply copy your existing `.svlint.toml` configuration into that directory.
  Ideally, add some comments to explain the background of the configuration and
  open a [pull request](https://github.com/dalance/svlint/pulls) to have it
  included as part of this project.
  This is the (initially) lower-effort approach, best suited to small personal
  projects with low requirements for documentation.
2. Create a definition in Markdown to compose a ruleset from a sequence of
  TOML fragments , i.e. write `md/ruleset-foo.md` to describe how the
  configuration in `rulesets/foo.toml` should be formed.
  Again, please open a [pull request](https://github.com/dalance/svlint/pulls)
  to have it included as part of this project.
  This approach is initially higher-effort but on larger projects, users will
  appreciate a good explanation of why configurations are necessary.

The rest of this section refers to the second method, which is a variant of
[literate programming](https://en.wikipedia.org/wiki/Literate_programming).

If you only use one configuration, there isn't much benefit in having wrapper
scripts, i.e. the benefits appear when you regularly use several
configurations.
For example, say you work on two projects called "A" and "B", and each project
has its own preferences for naming conventions.
This situation can be troublesome because there are many ways to get confused
about which configuration file should be used on which files.
Wrapper scripts help this situation by providing convenient commands like
`svlint-A` and `svlint-B`.
Another case for convenient access to specific rulesets is where you want to
check that some files adhere to a particular set of rules, e.g. rules to
reduce synthesis/simulation mismatches should apply to `design/*.sv` but not
apply to `verif/*.sv`.

Each ruleset specification (in `md/ruleset-*.md`) is processed individually.
A ruleset specification is freeform Markdown containing codeblocks with TOML
(toml), POSIX shell (sh), or Windows batch (winbatch) language markers.
Each ruleset specifies exactly one TOML configuration, one POSIX shell script,
and one Windows batch script.
For example, let this ruleset specification be placed in
`md/ruleset-an-example.md`:

    This is freeform Markdown.

    Some explanation of how the **foo** and **bar** rules work together
    with the associated option **blue**.
    ```toml
    textrules.foo = true
    syntaxrules.bar = true
    option.blue = "ABC"
    ```

    Next, some text about the **baz** rule and another option **red**.
    ```toml
    # A comment here.
    syntaxrules.baz = true
    option.red = "DEF"
    ```

    Maybe some more Markdown text here.

This example will produce three files under `rulesets/` when cargo builds this
crate: `an-example` (a POSIX shell script), `an-example.cmd` (a Windows batch
script), and `an-example.toml`.
A ruleset's TOML configuration is generated by concatenating all TOML
codeblocks into one file, so the above example will produce this TOML file:
```toml
textrules.foo = true
syntaxrules.bar = true
option.blue = "ABC"
# A comment here.
syntaxrules.baz = true
option.red = "DEF"
```

POSIX shell scripts begin with this header, where "an-example" is replaced by
the ruleset's name:
```sh
#!/usr/bin/env sh
set -e

# If flag/options are given that don't use the ruleset config, simply run
# svlint with the given arguments.
NONRULESET="-h|--help|-V|--version|--dump-filelist|-E|--example|--update"
if printf "%b\n" " $*" | grep -Eq " (${NONRULESET})";
then
  svlint $*
  exit $?
fi

SVLINT_CONFIG="$(dirname $(command -v svlint-an-example))/an-example.toml"

# Delete ANSI control sequences that begin with ESC and (usually) end with m.
# Delete ASCII control characters except line feed ('\n' = 0o12 = 10 = 0x0A).
SANS_CONTROL="| sed -e 's/\\o33\\[[0-9;]*[mGKHF]//g'"
SANS_CONTROL="${SANS_CONTROL} | tr -d '[\\000-\\011\\013-\\037\\177]'"

# Combine the above output sanitization fragments into variables which can be
# evaluated and processed with xargs, e.g:
#   eval "${SVFILES}" | xargs -I {} sh -c "grep foo {};"
# NOTE: Creating a variable with the result (instead of the command) would lead
# to undefined behavior where the list of file paths exceeds 2MiB.
SVFILES="svlint --dump-filelist=files $* ${SANS_CONTROL}"
SVINCDIRS="svlint --dump-filelist=incdirs $* ${SANS_CONTROL}"
```
Next, any codeblocks with the `sh` language marker are concatenated to
the header in order before, finally, this footer is appended:
```sh
env SVLINT_CONFIG="${SVLINT_CONFIG}" svlint $*
```
The final command calls the main `svlint` executable, wherever it is on your
`$PATH`, with the environment variable `SVLINT_CONFIG` pointing to a TOML
configuration in the same directory as the wrapper script.
Any command line arguments given to the wrapper script are passed on to the
main executable (via `$*`).
When svlint searches for a configuration (`src/main.rs::search_config()`), the
environment variable is chosen in preference to the `--config` flag which
prevents confusing cases:

1. Where the script is given the option, e.g. `svlint-foo --config=bar *.sv`.
  As the environment variable is set, the option `--config=bar` is ignored.
  If a user wishes to pass a different configuration, they'll need to call the
  main executable like `svlint --config=bar *.sv`.
2. Where the environment variable is not set or is invalid, the `--config`
  value (defaulting to `.svlint.toml`) is searched for hierarchically,
  beginning in the current directory then moving upwards to filesystem
  ancestors.

If instead the `--config` option was used in wrapper scripts, this could lead
to confusion where TOML files exist elsewhere in the hierarchy.

It isn't essential for all ruleset scripts to be POSIX compliant, but POSIX
compliance should be encourage because it allows for consistent behavior across
the widest range of systems.
The utilities used in the POSIX wrappers are specified in the current POSIX
standard (IEEE1003.1-2017, Volume 3: Shell and Utilities).
Some resources related to these components:

- [`env`](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/env.html)
  Included in the Single Unix Specification since
  X/Open Portability Guide Issue 2 (1987).
- [`sh`](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sh.html)
  Included in the Single Unix Specification since
  X/Open Portability Guide Issue 2 (1987).
- [`set`](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#set)
  Specified in Section 2.14 Special Built-In Utilities, and available since
  (at least) X/Open Portability Guide Issue 2 (1987).
- [`printf`](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/printf.html)
  Included in the Single Unix Specification since
  X/Open Common Application Environment (CAE) Specification Issue 4 (1994).
- [`grep`](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/grep.html)
  Included in the Single Unix Specification since
  X/Open Portability Guide Issue 2 (1987).
- [`command`](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/command.html)
  Included in the Single Unix Specification since
  X/Open Common Application Environment (CAE) Specification Issue 4 (1994).
- [`dirname`](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html)
  Included in the Single Unix Specification since
  X/Open Portability Guide Issue 2 (1987).
- [`sed`](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sed.html)
  Included in the Single Unix Specification since
  X/Open Portability Guide Issue 2 (1987).
- [`tr`](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/tr.html)
  Included in the Single Unix Specification since
  X/Open Portability Guide Issue 2 (1987).

Windows batch scripts begin with this header, where "an-example" is replaced by
the ruleset's name:
```winbatch
@echo off
for /f %%E in ('where.exe /f svlint-an-example') do (
    set "SVLINT_CONFIG=%%~dpEan-example.toml"
)
```
Next, any codeblocks with the `winbatch` language marker are then concatenated
to the header in order before, finally, this footer is appended:
```winbatch
svlint %*
```

The batch script template is designed for Windows XP and later, using the
`cmd.exe` shell.
Some useful resources for Windows batch script commands:

- [`echo`](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/echo)
- [`for`](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/for)
- [`where`](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/where)
- [`set`](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/set_1)

These wrapper scripts can then be used with svlint's usual arguments like
`svlint-foo path/to/design/*.sv`.
Note that this style of wrapper script allows you to use `$PATH` environment
variable in the usual way, and that the wrapper scripts will simply use the
first version of `svlint` found on your `$PATH`.

This method of generating a configuration and wrapper scripts enables full
flexibility for each ruleset's requirements, while encouraging full and open
documentation about their construction.
The process, defined in `src/mdgen.rs`, is deterministic so both the Markdown
specifications and the TOML configurations are tracked by versions control.
However, wrapper scripts are not installed alongside the `svlint` binary
created via `cargo install svlint` (or similar).
Instead, you must either add `rulesets/` to your `$PATH` environment variable,
or copy the wrapper scripts to somewhere already on your `$PATH`.
